Nick Morrison & Pat Fant
EC450
May 1, 2015
Final Project Report
	
When we began the ideation process, it became apparent that one similarity between us was our affinity for music. Therefore we thought through possible music projects, arriving at the idea of a synthesizer. It seemed ideal as we were able to immediately think of how we would implement features from a synth, and some of our homeworks prepared us well for a project like this. Therefore, the goal of this project was to build a working synth which could emulate as many of the features of a full scale synth as possible. 

The two main features we settled upon for our miniature synth were arpeggio and glissando mode. An arpeggio is a musical technique in which a chord is played as a sequence of notes, instead of in unison.  A glissando is a slide from one pitch to another. We set up an array of six pushbuttons to represent keys, with each corresponding to a note on the E pentatonic minor scale. They were connected to the MSP430 using P1.2-P1.7. We used this scale as it offers a lot of options musically, and only requires six inputs on the MSP430. Switching between the two modes is done using a pushbutton connected to P2.1, utilizing the P2 interrupt to switch modes asynchronously. When pressed, it flips the “mode” variable between 0 and 1, with 0 corresponding to glissando mode, and 1 to arpeggio mode. We used a potentiometer, connected to P1.0, to allow for tempo control. In glissando mode, it controls the “velocity” of the slide while in arpeggio mode it controls the tempo of the arpeggios. We utilized the MSP430’s ADC10 to produce the value from the “pot”, which ranged from 0-1024 depending on the knob position. The high end of these values are simply too great to be used for tempo control, so we divided the input to still provide a smooth range of tempos. Overall, the physical elements of the system consisted of a MSP430G2553 microprocessor, 7 pushbuttons, 1 small speaker, 1 10 kilo-ohm potentiometer, and a breadboard to implement the externals. Internally, we utilized the WDT, TimerA, ADC10, and the P2 interrupt. The system was powered through the MSP430, connected by USB to a laptop.	

Now for a more in depth explanation of glissando mode. As stated earlier, a glissando is a slide between two pitches. We implemented this as a slide between frequencies. Therefore if note E4 is played (330 Hz) followed by B (494 Hz), the system would play a tone at 330 Hz followed by tones ascending in frequency up to 494 Hz. To do this, we set the WDT to interval timer mode with SMCLK as the source, to check for button presses within the WDT interrupt. If one of the buttons was pressed, the corresponding note would be added to the note array. The note array holds all the notes that are depressed during the current clock cycle. The array is unnecessary for this mode as only one note is designed to be played at once, but it is necessary for the arpeggio mode. The note is played using TimerA, specifically by changing the period register TA0CCR0 to the half-period of the frequency of the note. For glissando mode, when a button is pressed the program checks to see if the note is greater or less than the current value of TA0CCR0. If it is less than the current period, TA0CCR0 is decremented by the value given from the potentiometer. This will be at most 16, as we divided ADC10MEM (output of the pot) by 64 because we found that higher increments caused significant overshoots of the target note. If it is greater than TA0CCR0, TA0CCR0 will be incremented in the same fashion. This will continue on each WDT interrupt call until the correct half-period is achieved (or the button is no longer pressed) at which point the current frequency will be played until another note is played. This is all done within the WDT interval handler. Since we want to be able to play the buttons like keys, it was necessary for them to be checked on every clock cycle so no divisor was used. This allows for the player to stop a shift and change destination notes at any point. That is why instead of altering a clock divisor to achieve different rates of frequency shifts, we simply changed the increment/decrement applied to TA0CCR0.

The arpeggiator proved tricky to implement; for a simple repeating, ascending-pattern arpeggiator, we had to figure out an efficient way to loop through the notes of any chord inputted. We did this by iteratively checking the state of each pushbutton on each WDT interrupt: if the button is pressed, a variable representing the size of the chord is incremented and the half-period of the corresponding note is added to an a global array (the size variable is used as the index to push back into the array, essentially enqueueing the note). The playing of the arpeggio is done within the WDT as well. An index to the current note in the array is kept in memory, and on each WDT interrupt TA0CCR0 is set to the value of the array at that index. The index is then incremented modulo the size of the chord being played. Another feature in our arpeggiator is a tempo setting, which can be changed by adjusting the external potentiometer. We implemented this by using a down-counter variable to control the rate at which the array is parsed. The interval of this down-counter is a 10-bit number read from the potentiometer and converted into digital by ADC10. The ADC10 output is divided by 10 and then 12 is added to it. It is divided by 10 to scale the tempo while 12 is added because we found that less than 12, the frequency of the arpeggio became too high to discern the individual notes.

Overall, we were entirely successful in implementing the features which we sought to include. Originally, we were only planning to create the arpeggio mode, hence the original moniker of arpeggiator for our project. However, we were able to add the glissando mode as well since the arpeggio mode did not take as long as we projected. Therefore, we were able to achieve above and beyond our projections as both modes work as intended with very little shortcomings. So, for what we set out to do we were quite successful. Nonetheless, much more could be done to add to our design. One feature which we had hoped to include was the ability to select from all 9 pentatonic scales. This would make our project much more ubiquitous, as being limited to one pentatonic scale is not very realistic. Another feature which would be nice to add would be the ability to record and playback songs created using our project. This could allow a player to loop a sample they create and play over it, just like they would with a full size synthesizer. Additionally, it would be helpful to implement more keys to achieve a wider range of notes at once. Generally, most improvements would focus around implementing more and more features which are available on a full scale synthesizer.

The distribution between both partners was approximately even. We each focused on one of the modes. Nick worked mostly on the glissando mode, while Pat was in charge of the arpeggiator. We worked together to merge these functions, as well as on the layout of the external components. For the writing of the report, we both wrote about our respective functions, and Nick wrote about the overall design and assessment/next steps. Pat prepared the schematic as well as cleaned up our code for the final submission.

To conclude, this project proved to be an apt culmination of our learning in EC450. We managed to utilize three of the important peripherals we learned about extensively in this course. From the beginning of the course learning about the Watchdog Timer and the digital I/O pins, to TimerA and ADC10; all were necessary for the success of our project. In addition, it showed us the possibilities with just a simple microprocessor such as the MSP430 G2553. We did not even come close to utilizing all the features of our processor, and still were able to create a veritable synthesizer. Moreover, it gives an idea of scale when we look to the full scale processors employed in our modern computers, and their capabilities.
